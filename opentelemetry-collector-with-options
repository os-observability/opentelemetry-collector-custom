#!/bin/bash

PATCH_DIR="/etc/opentelemetry-collector/configs"

if [ -d "$PATCH_DIR" ]; then
    PATCH_FILES=$(ls "$PATCH_DIR"/*.yaml 2>/dev/null | sort)
    if [ -n "$PATCH_FILES" ]; then
        CONFIG_OPTIONS=""

        for PATCH_FILE in $PATCH_FILES; do
            CONFIG_OPTIONS+=" --config file:$PATCH_FILE"
        done
    fi
fi

wait_for_microshift() {
    local timeout=300  # seconds
    local elapsed=0
    local interval=5

    while ! systemctl is-active --quiet microshift.service; do
        elapsed=$((elapsed + interval))
        if [ $elapsed -ge $timeout ]; then
            echo "Warning: microshift.service is not running."
            return 1
        fi
        echo "Waiting for microshift.service to start up..."
        sleep $interval
    done
    return 0
}


# Set a default IP so that the microshift default config is also valid if
# microshift is installed but not running.
export K8S_HOST_IP=127.0.0.1
# setup microshift default receivers if microshift is installed.
if systemctl list-units --full -all | grep -Fq "microshift.service"; then
    export KUBECONFIG=/var/lib/microshift/resources/kubeadmin/kubeconfig
    if wait_for_microshift; then
        K8S_HOST_IP=$(oc get svc kubernetes -n default -o jsonpath='{.spec.clusterIP}')
        cat <<EOF | oc apply -f -
---
apiVersion: v1
kind: Namespace
metadata:
  name: observability
---
apiVersion: v1
kind: Service
metadata:
  name: ingest
  namespace: observability
spec:
  selector:
    app: opentelemetry-collector
  ports:
    - protocol: TCP
      port: 4317
      targetPort: 54317
EOF
        export MICROSHIFT_WORKLOAD_IP=$(oc get svc custom-service -n observability -o jsonpath='{.spec.clusterIP}')
        echo "Service ingest.observability has been assigned IP: $MICROSHIFT_WORKLOAD_IP"
    fi
fi

/usr/bin/opentelemetry-collector $CONFIG_OPTIONS
